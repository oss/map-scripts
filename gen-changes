#!/usr/bin/env python

import os
import os.path
import shutil
import smtplib
import subprocess
import urllib
import urllib2
import xml.etree.ElementTree as ET
import xml.dom.minidom as MD
from email import Encoders
from email.MIMEBase import MIMEBase
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
from email.Utils import formatdate

import argparse
from shapely.geometry import box, Point, LineString
from shapely.wkt import loads

# URL for latest NJ pbf
NJ_LATEST = ("http://download.geofabrik.de/"
             "north-america/us/new-jersey-latest.osm.pbf")

# Disk locations for latest and previous NJ pbf
NJ_LATEST_PBF = '/army/new-jersey-latest.osm.pbf'
NJ_OLD_PBF = '/army/new-jersey-old.osm.pbf'

# Diff and changes disk locations
DIFF = '/army/diff.osc'
CHANGES = '/army/changes'
PENDING = '/army/pending'


class OSMChange:
    """Simple wrapper for creating an osmChange.
    Create, modify, and delete are easily accessible
    from the functions provided here. They should mostly be
    appended to.
    """
    def __init__(self):
        self.osc = ET.Element('osmChange')
        self.osc.set('version', '0.6')
        ET.SubElement(self.osc, 'create')
        ET.SubElement(self.osc, 'modify')
        ET.SubElement(self.osc, 'delete')

    def __repr__(self):
        return ET.tostring(self.osc)

    def get_create(self):
        return self.osc[0]

    def get_modify(self):
        return self.osc[1]

    def get_delete(self):
        return self.osc[2]

    def dump(self):
        ET.dump(self.osc)


def nominatim_url(query, **kwargs):
    """Build a url for nominatim to get osm info
    from a string
    """
    # base url
    nominatimurl = 'http://nominatim.openstreetmap.org/search/'
    # add on the query
    if query is not None:
        nominatimurl += query
    # return if we're done
    if not kwargs:
        return nominatimurl
    nominatimurl += '?'
    for kwarg in kwargs:
        # only add on the & if we haven't just added on the ?
        if nominatimurl[len(nominatimurl)-1] != '?':
            nominatimurl += '&'
        # put kwarg with the format key=value
        nominatimurl += kwarg + '=' + kwargs[kwarg]
    return nominatimurl


def parse_api_url(url):
    """Turn a url into a parsed ElementTree
    Assumes that the url leads to xml
    """
    print url
    f = urllib2.urlopen(url)
    root = ET.fromstring(f.read())
    f.close()
    return root


def read_element(element, nid):
    """Get a node/way/relation from osm"""
    return parse_api_url(
        "http://api.openstreetmap.org/api/0.6/{0}/{1}".format(element, nid))


def get_by_name(name, format='xml', bbox=None):
    """Get a shape based on a string. Use nominatim to get
    the most likely candidate
    """
    name_search = None
    if bbox is not None:
        str_bbox = "{0},{1},{2},{3}".format(*bbox)
        name_search = parse_api_url(nominatim_url(name,
                                                  format=format,
                                                  viewboxlbrt=str_bbox,
                                                  polygon_text="1"))
    else:
        name_search = parse_api_url(nominatim_url(name, format=format,
                                                  polygon_text="1"))
    return name_search


def print_ET(root):
    """Pretty print xml from ElementTree"""
    print MD.parseString(ET.tostring(root)).toprettyxml(),


def name_to_polygon(name, bbox=None):
    name_root = get_by_name(urllib.quote(name), bbox=bbox)
    polygon = loads(name_root[0].attrib['geotext'])
    return polygon


def send_mail(changes, address):
    """Send email requesting maps approval."""
    msg = MIMEMultipart()
    msg['From'] = 'phantoon'
    msg['To'] = address
    msg['Date'] = formatdate(localtime=True)
    msg['Subject'] = "Changes for Rutgers maps need approval"
    msg.attach(MIMEText(
        "The attached files need approval, run "
        "'/usr/bin/commit-changes' on phantoon to allow or deny changes"))
    for change in changes:
        part = MIMEBase('text', 'xml')
        part.set_payload(open(change, "r").read())
        Encoders.encode_base64(part)
        part.add_header('Content-Disposition', 'attachment; filename="{0}"'.
                        format(os.path.basename(change)))
        msg.attach(part)
    smtp = smtplib.SMTP('localhost')
    smtp.sendmail('phantoon', address, msg.as_string())
    smtp.close()


def get_new_jersey(outfile, nj_latest):
    """Download latest version of New Jersey from geofabrik"""
    with open(outfile, 'w') as f:
        f.write(urllib2.urlopen(nj_latest).read())


def max_bbox(bbox1, bbox2):
    val = [min(bbox1[0], bbox2[0]),
           min(bbox1[1], bbox2[1]),
           max(bbox1[2], bbox2[2]),
           max(bbox1[3], bbox2[3])]
    print val
    return val


def get_bbox(node, bboxes):
    """Get bounding box around a node from an ElementTree"""
    bbox = [180, 90, -180, -90]
    if node.tag == "node":
        lat = float(node.attrib['lat'])
        lon = float(node.attrib['lon'])
        bboxes[node.attrib['id']] = (lon, lat, lon, lat)
    else:
        find = "nd"
        if node.tag == "member":
            find = "member"
        for element in node.findall(find):
            element_type = "node"
            if find == "member":
                element_type = element.attrib['type']
            try:
                elem_box = bboxes[element.attrib['ref']]
            except KeyError:
                elem_box = get_bbox(read_element(element_type,
                                    element.attrib['ref'])[0], bboxes)
            bbox = max_bbox(bbox, elem_box)
        bboxes[node.attrib['id']] = (bbox[0], bbox[1], bbox[2], bbox[3])
    return bboxes[node.attrib['id']]


def lowest_avail_id(directory):
    current_ids = set(
        [int(os.path.splitext(f)[0]) for f in os.listdir(directory)])

    lowest_id = 1
    while lowest_id in current_ids:
        lowest_id += 1

    return lowest_id


def get_rutgers():
    rutgers_bbox = [-74.5343, 40.4164, -74.3520, 40.5673]
    busch = name_to_polygon("Rutgers Busch Campus", bbox=rutgers_bbox)
    livi = name_to_polygon("Rutgers Livingston Campus", bbox=rutgers_bbox)
    college_ave = name_to_polygon("Rutgers University - New Brunswick",
                                  bbox=rutgers_bbox)
    return [busch, livi, college_ave]


def lowest_avail_filename(directory):
    return os.path.join(directory, str(lowest_avail_id(directory)) + '.osc')


def intersects_any(bbox, rutgers):
    for campus in rutgers:
        if bbox.intersects(campus):
            return True
    return False


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Create change files based on a bounding box')
    parser.add_argument('-u', '--nj-url',
                        default=NJ_LATEST,
                        help='Url to get pbf from')
    parser.add_argument('-l', '--nj-latest',
                        default=NJ_LATEST_PBF,
                        help='Location to save new pbf')
    parser.add_argument('-o', '--nj-old',
                        default=NJ_OLD_PBF,
                        help='Location of the old pbf')
    parser.add_argument('-d', '--diff',
                        default=DIFF,
                        help='Diff location')
    parser.add_argument('-c', '--changes',
                        default=CHANGES,
                        help='Changes directory')
    parser.add_argument('-p', '--pending',
                        default=PENDING,
                        help='Pending directory')
    parser.add_argument('-s', '--short-circuit',
                        action='store_true')
    parser.add_argument('-m', '--no-send-mail',
                        action='store_true',
                        help='Add to stop mail sending')
    args = parser.parse_args()

    if not args.short_circuit:
        # Command run for osmosis, this command takes the two
        # pbfs and creates a new xml file that is the difference
        # between the two
        osmosis_cmd = [
            'osmosis',
            '--read-pbf',
            'file={0}'.format(args.nj_old),
            '--read-pbf',
            'file={0}'.format(args.nj_latest),
            '--derive-change',
            '--simplify-change',
            '--write-xml-change',
            'file={0}'.format(args.diff)
        ]

        print "Moving old New Jersey file"
        shutil.move(args.nj_latest, args.nj_old)

        print "Getting new New Jersey file"
        get_new_jersey(args.nj_latest, args.nj_url)

        print "Calling osmosis"
        subprocess.check_call(osmosis_cmd)

        print "Removing old NJ file"
        os.remove(args.nj_old)

    rutgers = get_rutgers()

    print "Parsing diff"
    changes = ET.parse(args.diff)

    apply_i = OSMChange()
    ask_p = OSMChange()

    bboxes = {}

    print "Calculating bounding boxes"
    for change in changes.getroot():
        for node in change:
            bbox = get_bbox(node, bboxes)
            # check if the entity has no width or height
            if bbox[0] == bbox[2] and bbox[1] == bbox[3]:
                bbox = Point(bbox[0], bbox[1])
            # check if just width xor height is missing
            elif bbox[0] == bbox[2]:
                bbox = LineString([(bbox[1], bbox[3])])
            elif bbox[1] == bbox[3]:
                bbox = LineString([(bbox[0], bbox[2])])
            else:
                bbox = box(*get_bbox(node, bboxes))
            print bbox
            append_osc = apply_i
            if intersects_any(bbox, rutgers):
                append_osc = ask_p
            if change.tag == "create":
                append_osc.get_create().append(node)
            elif change.tag == "modify":
                append_osc.get_modify().append(node)
            else:
                append_osc.get_delete().append(node)

    print "Writing files"
    change_filename = lowest_avail_filename(args.changes)
    pending_filename = lowest_avail_filename(args.pending)
    with open(change_filename, 'w') as f:
        f.write(str(apply_i))
    with open(pending_filename, 'w') as f:
        f.write(str(ask_p))

    if not args.no_send_mail:
        print "Sending mail"
        send_mail([change_filename, pending_filename],
                  'mwr54@nbcs.rutgers.edu')
