#!/usr/bin/env python

import os
import os.path
import shutil
import smtplib
import subprocess
import urllib
import urllib2
import xml.etree.ElementTree as ET
import xml.dom.minidom as MD
from email import Encoders
from email.MIMEBase import MIMEBase
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
from email.Utils import formatdate
from osm.models import OSMChange
import osm

import argparse
from shapely.geometry import box, Point, LineString
from shapely.wkt import loads

# URL for latest NJ pbf
NJ_LATEST = ("http://download.geofabrik.de/"
             "north-america/us/new-jersey-latest.osm.pbf")

# Disk locations for latest and previous NJ pbf
NJ_LATEST_PBF = '/army/new-jersey-latest.osm.pbf'
NJ_OLD_PBF = '/army/new-jersey-old.osm.pbf'

# Diff and changes disk locations
DIFF = '/army/diff.osc'
CHANGES = '/army/changes'
PENDING = '/army/pending'


def print_ET(root):
    """Pretty print xml from ElementTree"""
    print MD.parseString(ET.tostring(root)).toprettyxml(),


def send_mail(changes, address):
    """Send email requesting maps approval."""
    msg = MIMEMultipart()
    msg['From'] = 'phantoon'
    msg['To'] = address
    msg['Date'] = formatdate(localtime=True)
    msg['Subject'] = "Changes for Rutgers maps need approval"
    msg.attach(MIMEText(
        "The attached files need approval, run "
        "'/usr/bin/commit-changes' on phantoon to allow or deny changes"))
    for change in changes:
        part = MIMEBase('text', 'xml')
        part.set_payload(open(change, "r").read())
        Encoders.encode_base64(part)
        part.add_header('Content-Disposition', 'attachment; filename="{0}"'.
                        format(os.path.basename(change)))
        msg.attach(part)
    smtp = smtplib.SMTP('localhost')
    smtp.sendmail('phantoon', address, msg.as_string())
    smtp.close()


def get_new_jersey(outfile, nj_latest):
    """Download latest version of New Jersey from geofabrik"""
    with open(outfile, 'w') as f:
        f.write(urllib2.urlopen(nj_latest).read())


def get_bbox(node, bboxes):
    """Get bounding box around a node from an ElementTree"""
    bbox = [180, 90, -180, -90]
    if node.tag == "node":
        lat = float(node.attrib['lat'])
        lon = float(node.attrib['lon'])
        bboxes[node.attrib['id']] = (lon, lat, lon, lat)
    else:
        find = "nd"
        if node.tag == "relation":
            find = "member"
        for element in node.findall(find):
            try:
                elem_box = bboxes[element.attrib['ref']]
            except KeyError:
                element_type = "node"
                if find == "member":
                    element_type = element.attrib['type']
                osm_id = int(element.attrib['ref'])
                q = osm.osm_func(element_type, Point, Line, Polygon)
                print "osm_id: " + str(osm_id)
                print "q: " + str(q)
                print element_type
                result = session.query(q).filter_by(osm_id=osm_id).first().way
                xp1, yp1, xp2, yp2 = to_shape(result).bounds

                prj = Proj(init='epsg:3857')
                x1, y1 = prj(xp1, yp1, inverse=True)
                x2, y2 = prj(xp2, yp2, inverse=True)
                elem_box = [x1, y1, x2, y2]
            bbox = max_bbox(bbox, elem_box)
        bboxes[node.attrib['id']] = (bbox[0], bbox[1], bbox[2], bbox[3])
    return bboxes[node.attrib['id']]


def lowest_avail_id(directory):
    current_ids = set(
        [int(os.path.splitext(f)[0]) for f in os.listdir(directory)])

    lowest_id = 1
    while lowest_id in current_ids:
        lowest_id += 1

    return lowest_id


def get_rutgers():
    rutgers_bbox = [-74.5343, 40.4164, -74.3520, 40.5673]
    busch = name_to_polygon("Rutgers Busch Campus", bbox=rutgers_bbox)
    livi = name_to_polygon("Rutgers Livingston Campus", bbox=rutgers_bbox)
    college_ave = name_to_polygon("Rutgers University - New Brunswick",
                                  bbox=rutgers_bbox)
    return [busch, livi, college_ave]


def lowest_avail_filename(directory):
    return os.path.join(directory, str(lowest_avail_id(directory)) + '.osc')


def intersects_any(bbox, rutgers):
    for campus in rutgers:
        if bbox.intersects(campus):
            return True
    return False


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Create change files based on a bounding box')
    parser.add_argument('-u', '--nj-url',
                        default=NJ_LATEST,
                        help='Url to get pbf from')
    parser.add_argument('-l', '--nj-latest',
                        default=NJ_LATEST_PBF,
                        help='Location to save new pbf')
    parser.add_argument('-o', '--nj-old',
                        default=NJ_OLD_PBF,
                        help='Location of the old pbf')
    parser.add_argument('-d', '--diff',
                        default=DIFF,
                        help='Diff location')
    parser.add_argument('-c', '--changes',
                        default=CHANGES,
                        help='Changes directory')
    parser.add_argument('-p', '--pending',
                        default=PENDING,
                        help='Pending directory')
    parser.add_argument('-s', '--short-circuit',
                        action='store_true')
    parser.add_argument('-m', '--no-send-mail',
                        action='store_true',
                        help='Add to stop mail sending')
    args = parser.parse_args()

    if not args.short_circuit:
        # Command run for osmosis, this command takes the two
        # pbfs and creates a new xml file that is the difference
        # between the two
        osmosis_cmd = [
            'osmosis',
            '--read-pbf',
            'file={0}'.format(args.nj_latest),
            '--read-pbf',
            'file={0}'.format(args.nj_old),
            '--derive-change',
            '--simplify-change',
            '--sort',
            '--write-xml-change',
            'file={0}'.format(args.diff)
        ]

        print "Moving old New Jersey file"
        shutil.move(args.nj_latest, args.nj_old)

        print "Getting new New Jersey file"
        get_new_jersey(args.nj_latest, args.nj_url)

        print "Calling osmosis"
        subprocess.check_call(osmosis_cmd)

        print "Removing old NJ file"
        os.remove(args.nj_old)

    rutgers = get_rutgers()

    print "Parsing diff"
    changes = ET.parse(args.diff)

    apply_i = OSMChange()
    ask_p = OSMChange()

    bboxes = {}

    print "Calculating bounding boxes"
    for change in changes.getroot():
        for node in change:
            if node.tag == "bounds":
                continue
            bbox = get_bbox(node, bboxes)
            # check if the entity has no width or height
            if bbox[0] == bbox[2] and bbox[1] == bbox[3]:
                bbox = Point(bbox[0], bbox[1])
            # check if just width xor height is missing
            elif bbox[0] == bbox[2]:
                bbox = LineString([(bbox[1], bbox[3])])
            elif bbox[1] == bbox[3]:
                bbox = LineString([(bbox[0], bbox[2])])
            else:
                bbox = box(*bbox)
            print bbox
            append_osc = apply_i
            if intersects_any(bbox, rutgers):
                append_osc = ask_p
            if change.tag == "create":
                append_osc.create.append(node)
            elif change.tag == "modify":
                append_osc.modify.append(node)
            else:
                append_osc.delete.append(node)

    print "Writing files"
    change_filename = lowest_avail_filename(args.changes)
    pending_filename = lowest_avail_filename(args.pending)
    with open(change_filename, 'w') as f:
        f.write(str(apply_i))
    with open(pending_filename, 'w') as f:
        f.write(str(ask_p))

    if not args.no_send_mail:
        print "Sending mail"
        send_mail([change_filename, pending_filename],
                  'mwr54@nbcs.rutgers.edu')
