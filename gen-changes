#!/usr/bin/env python

import urllib
import urllib2
import shutil
import subprocess
import xml.etree.ElementTree as ET
import xml.dom.minidom
from shapely.geometry import box
from shapely.wkt import loads
import argparse

import smtplib
import os
import os.path
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
from email.MIMEBase import MIMEBase
from email.Utils import formatdate
from email import Encoders

# URL for latest NJ pbf
NJ_LATEST = ("http://download.geofabrik.de/"
             "north-america/us/new-jersey-latest.osm.pbf")

# Disk locations for latest and previous NJ pbf
NJ_LATEST_PBF = '/army/new-jersey-latest.osm.pbf'
NJ_OLD_PBF = '/army/new-jersey-old.osm.pbf'

# Diff and changes disk locations
DIFF = '/army/diff.osc'
CHANGES = '/army/changes'
PENDING = '/army/pending'

# Command run for osmosis, this command takes the two
# pbfs and creates a new xml file that is the difference
# between the two
OSMOSIS_CMD = [
    'osmosis',
    '--read-pbf',
    'file={0}'.format(NJ_OLD_PBF),
    '--read-pbf',
    'file={0}'.format(NJ_LATEST_PBF),
    '--derive-change',
    '--write-xml-change',
    'file={0}'.format(DIFF)
]


class OSMChange:
    """Simple wrapper for creating an osmChange.
    Create, modify, and delete are easily accessible
    from the functions provided here. They should mostly be
    appended to.
    """
    def __init__(self):
        self.osc = ET.Element('osmChange')
        self.osc.set('version', '0.6')
        ET.SubElement(self.osc, 'create')
        ET.SubElement(self.osc, 'modify')
        ET.SubElement(self.osc, 'delete')

    def __repr__(self):
        return ET.tostring(self.osc)

    def get_create(self):
        return self.osc[0]

    def get_modify(self):
        return self.osc[1]

    def get_delete(self):
        return self.osc[2]

    def dump(self):
        ET.dump(self.osc)


def nominatim_url(query, **kwargs):
    """Build a url for nominatim to get osm info
    from a string
    """
    # base url
    nominatimurl = 'http://nominatim.openstreetmap.org/search/'
    if query is not None:
        nominatimurl += query
    if not kwargs:
        return nominatimurl
    nominatimurl += '?'
    for kwarg in kwargs:
        # only add on the & if we haven't just added on the ?
        if nominatimurl[len(nominatimurl)-1] != '?':
            nominatimurl += '&'
        nominatimurl += kwarg + '=' + kwargs[kwarg]
    return nominatimurl


def parse_api_url(url):
    """Turn a url into a parsed ElementTree"""
    print url
    f = urllib2.urlopen(url)
    root = ET.fromstring(f.read())
    f.close()
    return root


def read_element(element, nid):
    """Get a node/way/relation from osm"""
    return parse_api_url(
        "http://api.openstreetmap.org/api/0.6/{0}/{1}".format(element, nid))


def get_by_name(name, format='xml', bbox=None):
    """Get a shape based on a string. Use nominatim to get
    the most likely candidate
    """
    name_search = None
    if bbox is not None:
        str_bbox = "{0},{1},{2},{3}".format(*bbox)
        name_search = parse_api_url(nominatim_url(name,
                                                  format=format,
                                                  viewboxlbrt=str_bbox,
                                                  polygon_text="1"))
    else:
        name_search = parse_api_url(nominatim_url(name, format=format,
                                                  polygon_text="1"))
    return name_search


def print_ET(root):
    """Pretty print xml from ElementTree"""
    print xml.dom.minidom.parseString(ET.tostring(root)).toprettyxml(),


def name_to_polygon(name, bbox=None):
    name_root = get_by_name(urllib.quote(name), bbox=bbox)
    polygon = loads(name_root[0].attrib['geotext'])
    return polygon


def send_mail(changes, address):
    """Send email requesting maps approval."""
    msg = MIMEMultipart()
    msg['From'] = 'phantoon'
    msg['To'] = address
    msg['Date'] = formatdate(localtime=True)
    msg['Subject'] = "Changes for Rutgers maps need approval"
    msg.attach(MIMEText(
        "The attached files need approval, run "
        "'/usr/bin/commit-changes' on phantoon to allow or deny changes"))
    for change in changes:
        part = MIMEBase('text', 'xml')
        part.set_payload(open(change, "r").read())
        Encoders.encode_base64(part)
        part.add_header('Content-Disposition', 'attachment; filename="{0}"'.
                        format(os.path.basename(change)))
        msg.attach(part)
    smtp = smtplib.SMTP('localhost')
    smtp.sendmail('phantoon', address, msg.as_string())
    smtp.close()


def get_new_jersey(outfile, nj_latest):
    """Download latest version of New Jersey from geofabrik"""
    with open(outfile, 'w') as f:
        f.write(urllib2.urlopen(nj_latest).read())


def max_bbox(bbox1, bbox2):
    val = [min(bbox1[0], bbox2[0]),
           min(bbox1[1], bbox2[1]),
           max(bbox1[2], bbox2[2]),
           max(bbox1[3], bbox2[3])]
    print val
    return val


def get_bbox(node, bboxes):
    """Get bounding box around a node from an ElementTree"""
    bbox = [180, 90, -180, -90]
    if node.tag == "node":
        lat = float(node.attrib['lat'])
        lon = float(node.attrib['lon'])
        bboxes[node.attrib['id']] = (lat, lon, lat, lon)
    else:
        find = "nd"
        if node.tag == "member":
            find = "member"
        for element in node.findall(find):
            element_type = "node"
            if find == "member":
                element_type = element.attrib['type']
            try:
                elem_box = bboxes[element.attrib['ref']]
            except KeyError:
                elem_box = get_bbox(read_element(element_type,
                                    element.attrib['ref'])[0], bboxes)
            bbox = max_bbox(bbox, elem_box)
        bboxes[node.attrib['id']] = (bbox[0], bbox[1], bbox[2], bbox[3])
    return bboxes[node.attrib['id']]


def lowest_avail_id(directory):
    current_ids = set(
        [int(os.path.basename(f)) for f in os.listdir('/army/changes')])

    lowest_id = 1
    while lowest_id in current_ids:
        lowest_id += 1

    return lowest_id


def get_rutgers():
    rutgers_bbox = [-74.5343, 40.4164, -74.3520, 40.5673]
    busch = name_to_polygon("Rutgers Busch Campus", bbox=rutgers_bbox)
    livi = name_to_polygon("Rutgers Livingston Campus", bbox=rutgers_bbox)
    college_ave = name_to_polygon("Rutgers University - New Brunswick",
                                  bbox=rutgers_bbox)
    return [busch, livi, college_ave]


def lowest_avail_filename(directory):
    return os.path.join(directory, str(lowest_avail_id(directory)) + '.osc')


def intersects_any(bbox, rutgers):
    for campus in rutgers:
        if bbox.intersects(campus):
            return True
    return False


if __name__ == '__main__':

    parser = argparse.ArgumentParser(
        description='Create change files based on a bounding box')
    parser.add_argument('-u', '--nj-url',
                        default=NJ_LATEST,
                        help='Url to get pbf from')
    parser.add_argument('-l', '--nj-latest',
                        default=NJ_LATEST_PBF,
                        help='Location to save new pbf')
    parser.add_argument('-o', '--nj-old',
                        default=NJ_OLD_PBF,
                        help='Location of the old pbf')
    parser.add_argument('-d', '--diff',
                        default=DIFF,
                        help='Diff location')
    parser.add_argument('-c', '--changes',
                        default=CHANGES,
                        help='Changes directory')
    parser.add_argument('-p', '--pending',
                        default=PENDING,
                        help='Pending directory')
    parser.add_argument('-s', '--short-circuit',
                        action='store_true')
    args = parser.parse_args()

    rutgers = get_rutgers()

    print "Moving old New Jersey file"
    shutil.move(NJ_LATEST_PBF, NJ_OLD_PBF)

    print "Getting new New Jersey file"
    get_new_jersey(NJ_LATEST_PBF, NJ_LATEST)

    print "Calling osmosis"
    subprocess.check_call(OSMOSIS_CMD)

    print "Removing old NJ file"
    os.remove(NJ_OLD_PBF)

    print "Parsing diff"
    changes = ET.parse(DIFF)

    apply_i = OSMChange()
    ask_p = OSMChange()

    bboxes = {}

    print "Calculating bounding boxes"
    for change in changes.getroot():
        for node in change:
            bbox = box(*get_bbox(node, bboxes))
            append_osc = apply_i
            if intersects_any(bbox, rutgers):
                append_osc = ask_p
            if change.tag == "create":
                append_osc.get_create().append(node)
            elif change.tag == "modify":
                append_osc.get_modify().append(node)
            else:
                append_osc.get_delete().append(node)

    change_filename = lowest_avail_filename(CHANGES)
    pending_filename = lowest_avail_filename(PENDING)
    with open(change_filename, 'w') as f:
        f.write(str(apply_i))
    with open(pending_filename, 'w') as f:
        f.write(str(ask_p))

    send_mail([change_filename, pending_filename], 'mwr54@nbcs.rutgers.edu')
